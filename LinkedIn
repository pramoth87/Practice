#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jun 17 13:54:07 2021

@author: pchandrasekar
"""
"""
366. Find Leaves of Binary Tree

Given the root of a binary tree, collect a tree's nodes as if you were doing this:

Collect all the leaf nodes.
Remove all the leaf nodes.
Repeat until the tree is empty.

Example 1:

Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct 
answers since per each level it does not matter the order on which elements are returned.

Here's a simple python DFS implementation used to populate a dictionary (key = index, values = list of nodes), 
O(N) space, O(N) time, beats 99%

The DFS recursively calculates the layer index by getting the maximum depth from the left and right subtrees of a given node, 
which is then used to populate the dictionary.

"""
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

def findLeaves(self, root: TreeNode) -> List[List[int]]:
    output = collections.defaultdict(list)
    
    def dfs(node):
        if not node: 
            return 0 
        left = dfs(node.left)
        right = dfs(node.right)
        layer = max(left, right)
        output[layer].append(node.val)
        return layer + 1
    
    dfs(root)
    return output.values() 

"""
744. Find Smallest Letter Greater Than Target

Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.

Note that the letters wrap around.

For example, if target == 'z' and letters == ['a', 'b'], the answer is 'a'.
 

Example 1:

Input: letters = ["c","f","j"], target = "a"
Output: "c"

"""
#O(n) and O(1)

def nextGreatestLetter(letters, target):
    for c in letters:
        if c > target:
            return c
    return letters[0]

# Binary Search - O(log n) and O(1)

def nextGreatestLetter(letters, target):
    if target >= letters[-1] or target < letters[0]:
        return letters[0]
    
    l, r = 0, len(letters) - 1
    while l <= r:
        pivot = (l+r)//2
        if target >= letters[pivot]:
            l = pivot + 1
        elif target < letters[pivot]:
            r = pivot - 1

    if letters[r] <= target:
        return letters[r+1]
    
    else:
        return letters[r]

"""
339. Nested List Weight Sum

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.

Return the sum of each integer in nestedList multiplied by its depth.

Example 1:

Input: nestedList = [[1,1],2,[1,1]]
Output: 10
Explanation: Four 1's at depth 2, one 2 at depth 1. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.

https://leetcode.com/problems/nested-list-weight-sum/
"""
def depthSum(nestedList):

    def dfs(nested_list, depth):
        total = 0
        for nested in nested_list:
            if nested.isInteger():
                total += nested.getInteger() * depth
            else:
                total += dfs(nested.getList(), depth + 1)
        return total

    return dfs(nestedList, 1)

"""
65. Valid Number

A valid number can be split up into these components (in order):

A decimal number or an integer.
(Optional) An 'e' or 'E', followed by an integer.
A decimal number can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One of the following formats:
One or more digits, followed by a dot '.'.
One or more digits, followed by a dot '.', followed by one or more digits.
A dot '.', followed by one or more digits.
An integer can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One or more digits.
For example, all the following are valid numbers: ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"], while the following are not valid numbers: ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"].

Given a string s, return true if s is a valid number.

Example 1:

Input: s = "0"
Output: true
"""
def isNumber(s):
    seen_digit = seen_exponent = seen_dot =  False
    for i, c in enumerate(s):
        if c.isdigit():
            seen_digit = True
        elif c in ["+", "-"]:
            if i > 0 and s[i - 1] != "e" and s[i - 1] != "E":
                return False
        elif c in ["e", "E"]:
            if seen_exponent or not seen_digit:
                return False
            seen_exponent = True
            seen_digit = False
        elif c == ".":
            if seen_dot or seen_exponent:
                return False
            seen_dot = True
        else:
            return False
    
    return seen_digit

"""
716. Max Stack

Design a max stack data structure that supports the stack operations and supports finding the stack's maximum element.

Implement the MaxStack class:

MaxStack() Initializes the stack object.
void push(int x) Pushes element x onto the stack.
int pop() Removes the element on top of the stack and returns it.
int top() Gets the element on the top of the stack without removing it.
int peekMax() Retrieves the maximum element in the stack without removing it.
int popMax() Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the top-most one.
 

Example 1:

Input
["MaxStack", "push", "push", "push", "top", "popMax", "top", "peekMax", "pop", "top"]
[[], [5], [1], [5], [], [], [], [], [], []]
Output
[null, null, null, null, 5, 5, 1, 5, 1, 5]

Explanation
MaxStack stk = new MaxStack();
stk.push(5);   // [5] the top of the stack and the maximum number is 5.
stk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.
stk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.
stk.top();     // return 5, [5, 1, 5] the stack did not change.
stk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.
stk.top();     // return 1, [5, 1] the stack did not change.
stk.peekMax(); // return 5, [5, 1] the stack did not change.
stk.pop();     // return 1, [5] the top of the stack and the max element is now 5.
stk.top();     // return 5, [5] the stack did not change.
"""

class MaxStack(list):
    def push(self, x):
        m = max(x, self[-1][1] if self else None)
        self.append((x, m))

    def pop(self):
        return list.pop(self)[0]

    def top(self):
        return self[-1][0]

    def peekMax(self):
        return self[-1][1]

    def popMax(self):
        m = self[-1][1]
        b = []
        while self[-1][0] != m:
            b.append(self.pop())
        self.pop()
        map(self.push, reversed(b))
        return m
"""
34. Find First and Last Position of Element in Sorted Array

Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]

"""

def searchRange(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """
    
    def findPos(nums, target, leftMost):
        
        left = 0 
        right = len(nums)-1
        
        res = -1
        while(left <= right):
            mid = (left+right)//2
            if(nums[mid] == target):
                res = mid
                if(leftMost == True):
                    right = mid -1
                    continue
                else:
                    left = mid + 1
                    continue
            if(target >= nums[left] and target < nums[mid]):
                right = mid - 1
            else:
                left = mid + 1
        return res
    
    leftidx = findPos(nums, target, True)
    if leftidx == -1:
        return [-1,-1]
    rightidx = findPos(nums, target, False)
    return[leftidx, rightidx]

"""
200. Number of Islands

Given an m x n 2d grid map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. 
You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
"""
def island(grid):
    if len(grid) ==0:
        return 0
    rows = len(grid)
    cols = len(grid[0])
    visited = [[False for i in range(cols)] for j in range(rows)]
    
    islands_Count = 0
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1 and visited[i][j] == False:
                #visited[i][j] = True
                print(i,j)
                DFS(grid,i,j,visited,rows,cols)
                islands_Count += 1
    return islands_Count

def DFS(grid, i, j, visited, rows, cols):
    visited[i][j] = True
    print(i,j,visited)
    if i-1 >= 0 and visited[i-1][j]== False and grid[i-1][j]==1:
        DFS(grid,i-1,j,visited,rows,cols)
    if i+1 < rows and visited[i+1][j]== False and grid[i+1][j]==1:
        DFS(grid,i+1,j,visited,rows,cols)
    if j-1 >= 0 and visited[i][j-1]== False and grid[i][j-1]==1:
        DFS(grid,i,j-1,visited,rows,cols)
    if j+1 < cols and visited[i][j+1]==False and grid[i][j+1]==1:
        DFS(grid,i,j+1,visited,rows,cols)
        
    return  

"""
373. Find K Pairs with Smallest Sums

You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.

Define a pair (u, v) which consists of one element from the first array and one element from the second array.

Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.

Example 1:

Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
"""
def kSmallestPairs(nums1, nums2,k):
    pairs = []
    
    for let in nums1:
        
        for lets in nums2:
            pairs.append([let, lets])
    
    pairs = sorted(pairs, key = lambda x: x[0] + x[1])
    ans = []
    
    while k > 0 and pairs:
        ans.append(pairs.pop(0))
        k -= 1
        
    return ans

"""
Time complexity. GetRandom is always \mathcal{O}(1)O(1). 
Insert and Delete both have \mathcal{O}(1)O(1) average time complexity, 
and \mathcal{O}(N)O(N) in the worst-case scenario when the operation exceeds the capacity of currently allocated array/hashmap and invokes space reallocation.

Space complexity: \mathcal{O}(N)O(N), to store N elements.
380. Insert Delete GetRandom O(1)

Implement the RandomizedSet class:

bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
Follow up: Could you implement the functions of the class with each function works in average O(1) time?

 

Example 1:

Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
"""
from random import choice
class RandomizedSet():
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return choice(self.list)
    
"""
150. Evaluate Reverse Polish Notation

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, and /. Each operand may be an integer or another expression.

Note that division between two integers should truncate toward zero.

It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.

Example 1:

Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
"""
def evalRPN(tokens):
    
    stack = []
    
    for token in tokens:
        
        if token not in "+-/*":
            stack.append(int(token))
            continue
    
        number_2 = stack.pop()
        number_1 = stack.pop()
        
        result = 0
        if token == "+":
            result = number_1 + number_2
        elif token == "-":
            result = number_1 - number_2
        elif token == "*":
            result = number_1 * number_2
        else:
            result = int(number_1 / number_2)
            
        stack.append(result)

    return stack.pop()


"""
53. Maximum Subarray

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
"""

def maxSubArray(nums):
    # Initialize our variables using the first element.
    current_subarray = max_subarray = nums[0]
    
    # Start with the 2nd element since we already used the first one.
    for num in nums[1:]:
        # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
        current_subarray = max(num, current_subarray + num)
        max_subarray = max(max_subarray, current_subarray)
    
    return max_subarray
"""
152. Maximum Product Subarray

Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.

It is guaranteed that the answer will fit in a 32-bit integer.

A subarray is a contiguous subsequence of the array.

Example 1:

Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
"""

def maxProduct(nums):
    if len(nums) == 0:
        return 0

    max_so_far = nums[0]
    min_so_far = nums[0]
    result = max_so_far

    for i in range(1, len(nums)):
        curr = nums[i]
        temp_max = max(curr, max_so_far * curr, min_so_far * curr)
        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)

        max_so_far = temp_max

        result = max(max_so_far, result)

    return result

"""
68. Text Justification

Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.
 

Example 1:

Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
"""

def fullJustify(words,maxWidth):
    length = 0
    line = []
    ans = []
    for word in words:
        wLen = len(word)
        if length and length+wLen+1 > maxWidth:
            print(line)
            nw = len(line)
            total = maxWidth - (length - (nw-1))
            print(nw,total)
            if nw == 1:
                ans.append(line[0] + (' '*total))
            else:
                base, res = divmod(total, nw-1)
                for i in range(res):
                    line[i] += ' '
                    print("line",line)
                ans.append((' '*base).join(line))
                print("ans",ans)
            
            length = wLen
            line = [word]
        else:
            if line:
                length += 1 + wLen
            else:
                length += wLen
            line.append(word)
    
    if line:
        ans.append(' '.join(line) + ' '*(maxWidth - length))
    
    return ans

"""
1. Merge Two Sorted Lists

Merge two sorted linked lists and return it as a sorted list. 
The list should be made by splicing together the nodes of the first two lists.

Example 1:

Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]
"""
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(l1, l2):
        head = ListNode(-1)
        prev = head
        while l1 and l2:
            if l1.val >= l2.val:
                prev.next = l2
                l2 = l2.next
            else:
                prev.next = l1
                l1 = l1.next
            
            prev = prev.next
        
        prev.next = l1 if l1 is not None else l2
        return head.next
    
"""
244. Shortest Word Distance II

Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.

Implement the WordDistance class:

WordDistance(String[] wordsDict) initializes the object with the strings array wordsDict.
int shortest(String word1, String word2) returns the shortest distance between word1 and word2 in the array wordsDict.
 

Example 1:

Input
["WordDistance", "shortest", "shortest"]
[[["practice", "makes", "perfect", "coding", "makes"]], ["coding", "practice"], ["makes", "coding"]]
Output
[null, 3, 1]

Explanation
WordDistance wordDistance = new WordDistance(["practice", "makes", "perfect", "coding", "makes"]);
wordDistance.shortest("coding", "practice"); // return 3
wordDistance.shortest("makes", "coding");    // return 1
"""
from collections import defaultdict
class WordDistance:

    def __init__(self, words):
        """
        :type words: List[str]
        """
        self.locations = defaultdict(list)

        # Prepare a mapping from a word to all it's locations (indices).
        for i, w in enumerate(words):
            self.locations[w].append(i)

    def shortest(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        loc1, loc2 = self.locations[word1], self.locations[word2]
        l1, l2 = 0, 0
        min_diff = float("inf")

        # Until the shorter of the two lists is processed
        while l1 < len(loc1) and l2 < len(loc2):
            min_diff = min(min_diff, abs(loc1[l1] - loc2[l2]))
            if loc1[l1] < loc2[l2]:
                l1 += 1
            else:
                l2 += 1
        return min_diff
    
"""
102. Binary Tree Level Order Traversal

Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

Example 1:

Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
"""
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
def levelOrder(root):
    """
    :type root: TreeNode
    :rtype: List[List[int]]
    """
    q = deque()
    ans = []
    if root is None:
        return ans
    q.append(root)
    while q:
        n = len(q)
        val = []
        while n > 0:
            node = q.popleft()
            if node.left is not None:
                q.append(node.left)
            if node.right is not None:
                q.append(node.right)
            val.append(node.val)
            n -= 1
        ans.append(val)
    return ans

"""
254. Factor Combinations

Numbers can be regarded as the product of their factors.

For example, 8 = 2 x 2 x 2 = 2 x 4.
Given an integer n, return all possible combinations of its factors. You may return the answer in any order.

Note that the factors should be in the range [2, n - 1].

Example 1:

Input: n = 1
Output: []
Example 2:

Input: n = 12
Output: [[2,6],[3,4],[2,2,3]]
"""
def getFactors(n):
    res = []
    
    def helper(prev_factor, arr, n):
        for i in range(prev_factor, int(math.sqrt(n))+1):
            if not n%i:
                res.append(arr + [i, n//i])
                helper(i, arr + [i], n//i)
    helper(2, [], n)
    return res

"""
12. Integer to Roman

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral.

 

Example 1:

Input: num = 3
Output: "III"
"""
def intToRoman(num):
    num_map = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),
       (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
    roman = ''

    while num > 0:
        for i, r in num_map:
            while num >= i:
                roman += r
                num -= i
        return roman
    
"""
04. Maximum Depth of Binary Tree

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:

Input: root = [3,9,20,null,null,15,7]
Output: 3
"""

def maxDepth(root):
    """
    :type root: TreeNode
    :rtype: int
    """ 
    stack = []
    if root is not None:
        stack.append((1, root))
    
    depth = 0
    while stack != []:
        current_depth, root = stack.pop()
        if root is not None:
            depth = max(depth, current_depth)
            stack.append((current_depth + 1, root.left))
            stack.append((current_depth + 1, root.right))
    
    return depth

"""
50. Pow(x, n)

Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

 

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000
"""
def myPow(x,n):
    if n == 0:
        return 1
    
    curProduct = x
    res = 1
    while n > 0:
        if n % 2 == 1:
            res *= curProduct
        curProduct *= curProduct
        n //= 2
    return res

"""
69. Sqrt(x)

Given a non-negative integer x, compute and return the square root of x.

Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.

Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.

Example 1:

Input: x = 4
Output: 2
"""
def mySqrt(x):
    if x < 2:
        return x
    
    left, right = 2, x // 2
    
    while left <= right:
        pivot = left + (right - left) // 2
        num = pivot * pivot
        if num > x:
            right = pivot -1
        elif num < x:
            left = pivot + 1
        else:
            return pivot
        
    return right
"""
160. Intersection of Two Linked Lists

Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.

For example, the following two linked lists begin to intersect at node c1:

It is guaranteed that there are no cycles anywhere in the entire linked structure.

Note that the linked lists must retain their original structure after the function returns.

Example 1:

Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
"""
def getIntersectionNode(headA, headB):
    if headA is None or headB is None:
        return None
    A_pointer = headA
    B_pointer = headB
    while A_pointer != B_pointer:
        A_pointer = headB if A_pointer == None else A_pointer.next
        B_pointer = headA if B_pointer == None else B_pointer.next
    return A_pointer

"""
367. Valid Perfect Square

Given a positive integer num, write a function which returns True if num is a perfect square else False.

Follow up: Do not use any built-in library function such as sqrt.

Example 1:

Input: num = 16
Output: true
"""
def isPerfectSquare(num):
     if num < 2:
         return True
     
     left, right = 2, num // 2
     
     while left <= right:
         x = left + (right - left) // 2
         guess_squared = x * x
         if guess_squared == num:
             return True
         if guess_squared > num:
             right = x - 1
         else:
             left = x + 1
     
     return False
"""
297. Serialize and Deserialize Binary Tree

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example: 

You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"
"""
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
    
class code:
    def serialize(self,root):
        def serializeDFS(root,string):
            if root is None:
                string += 'None'
            else:
                string += str(root.val) + ','
                string = serializeDFS(root.left, string)
                string = serializeDFS(root.right, string)
        
            return string
        
        return serializeDFS(root, '')
    
    def deserialize(self,data):
        def deSerializeDFS(string):
            
            if string[0] == 'None':
                string.pop(0)
                return None
            root = TreeNode(string[0])
            string.pop(0)
            root.left = deSerializeDFS(string)
            root.right = deSerializeDFS(string)
            return root
        data_list = data.split(',')
        root = deSerializeDFS(data_list)
        return root

"""
01. Symmetric Tree

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

Example 1:


Input: root = [1,2,2,3,4,4,3]
Output: true
"""
    
class Solution:

    def isSymmetric(self,root):
        return self.isMirror(root, root)
    
    
    def isMirror(self, t1, t2):
        if not t1 and not t2: return True
        if not t1 or not t2: return False
        return t1.val == t2.val and self.isMirror(t1.right, t2.left) and self.isMirror(t1.left, t2.right)
    
    
"""
256. Paint House

There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. 
The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.

For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...
Return the minimum cost to paint all houses.

 

Example 1:

Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.
Minimum cost: 2 + 5 + 3 = 10.
"""

def minCost(self, costs):
    """
    :type costs: List[List[int]]
    :rtype: int
    """

    def paint_cost(n, color):
        if (n, color) in self.memo:
            return self.memo[(n, color)]
        total_cost = costs[n][color]
        if n == len(costs) - 1:
            pass
        elif color == 0:
            total_cost += min(paint_cost(n + 1, 1), paint_cost(n + 1, 2))
        elif color == 1:
            total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 2))
        else:
            total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 1))
        self.memo[(n, color)] = total_cost
        return total_cost

    if costs == []:
        return 0

    self.memo = {}
    return min(paint_cost(0, 0), paint_cost(0, 1), paint_cost(0, 2))

"""
76. Minimum Window Substring

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

A substring is a contiguous sequence of characters within the string.

Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
"""
def minWindow( s, t):
    """
    :type s: str
    :type t: str
    :rtype: str
    """
    if not t or not s:
        return ""
    dict_t = Counter(t)
    required = len(dict_t)
    # Filter all the characters from s into a new list along with their index.
    # The filtering criteria is that the character should be present in t.
    filtered_s = []
    for i, char in enumerate(s):
        if char in dict_t:
            filtered_s.append((i, char))
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float("inf"), None, None
    # Look for the characters only in the filtered list instead of entire s. This helps to reduce our search.
    # Hence, we follow the sliding window approach on as small list.
    while r < len(filtered_s):
        character = filtered_s[r][1]
        window_counts[character] = window_counts.get(character, 0) + 1
        if window_counts[character] == dict_t[character]:
            formed += 1
        # If the current window has all the characters in desired frequencies i.e. t is present in the window
        while l <= r and formed == required:
            character = filtered_s[l][1]
            # Save the smallest window until now.
            end = filtered_s[r][0]
            start = filtered_s[l][0]
            if end - start + 1 < ans[0]:
                ans = (end - start + 1, start, end)

            window_counts[character] -= 1
            if window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    
        r += 1    
    return "" if ans[0] == float("inf") else s[ans[1] : ans[2] + 1]
"""
23. Merge k Sorted Lists

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
"""

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists):
        nodes = []
        head = point = ListNode(0)
        
        for l in lists:
            while l:
                nodes.append(l.val)
                l = l.next
        
        for x in sorted(nodes):
            point.next = ListNode(x)
            point = point.next
        
        return head.next
"""
261. Graph Valid Tree

You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.

Return true if the edges of the given graph make up a valid tree, and false otherwise.

Example 1:

Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
""" 
def validTree(n, edges):
    
    if len(edges) != n - 1: return False
    
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    parent = {0: -1}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour == parent[node]:
                continue
            if neighbour in parent:
                return False
            parent[neighbour] = node
            stack.append(neighbour)
    
    return len(parent) == n

"""
243. Shortest Word Distance

Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list.

Example 1:

Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "coding", word2 = "practice"
Output: 3
Example 2:

Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1
"""

def shortestDistance(words, word1, word2):
    """
    :type words: List[str]
    :type word1: str
    :type word2: str
    :rtype: int
    """
    shortest = len(words)+1
    index = None
    found = None
    for i, word in enumerate(words):
        if word == word1 or word == word2:
            if found is not None:
                if word != found:
                    shortest = min(shortest, i - index)
            found = word
            index = i
    return shortest

"""
364. Nested List Weight Sum II

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth. Let maxDepth be the maximum depth of any integer.

The weight of an integer is maxDepth - (the depth of the integer) + 1.

Return the sum of each integer in nestedList multiplied by its weight.

Example 1:

Input: nestedList = [[1,1],2,[1,1]]
Output: 8
Explanation: Four 1's with a weight of 1, one 2 with a weight of 2.
1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8
"""

# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        maxdepth = 1
        ans = []
        def dfs(nl, depth=1):
            nonlocal maxdepth
            maxdepth=max(maxdepth, depth)
            if nl.isInteger():
                ans.append([nl.getInteger(), depth])
                return
            for i in nl.getList():
                dfs(i, depth+1)
        for nl in nestedList:         
            dfs(nl)
        print(ans,maxdepth)
        return sum(i * (maxdepth + 1 - d) for i, d in ans)   
    
"""
46. Permutations

Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.

Example 1:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:

Input: nums = [0,1]
Output: [[0,1],[1,0]]
Example 3:

Input: nums = [1]
Output: [[1]]
"""
def permute(self, nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    output = []
    def permuteUtil(nums, level):
        if level == len(nums):
            output.append(nums[:])
            return # Very Important
        for i in range(level, len(nums)):
            nums[i], nums[level] = nums[level], nums[i]
            permuteUtil(nums, level+1)
            nums[i], nums[level] = nums[level], nums[i]
        return
    
    permuteUtil(nums, 0)
    return output

"""
47. Permutations II

Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]

"""
def permuteUnique(nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    output = []
    def permuteUtil(uniq_chars, ccount, level, res):
        if level == len(res):
            output.append(res[:])
        for char in uniq_chars:
            if ccount[char] == 0:
                continue
            else:
                res[level] = char
                ccount[char] -= 1
                permuteUtil(uniq_chars, ccount, level+1, res)
                ccount[char]+= 1
        return
    res = [0] * len(nums)
    ccount = {}
    for i in nums:
        if i in ccount:
            ccount[i] += 1
        else:
            ccount[i] = 1
    uniq_chars = sorted(ccount.keys())
    #print ccount, uniq_chars
    permuteUtil(uniq_chars, ccount, 0, res)
    return output

"""
20. Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
 

Example 1:

Input: s = "()"
Output: true
"""

def isValid(s):
    bracket_map = {"(": ")", "[": "]",  "{": "}"}
    open_par = set(["(", "[", "{"])
    stack = []
    for i in s:
        if i in open_par:
            stack.append(i)
        elif stack and i == bracket_map[stack[-1]]:
                stack.pop()
        else:
            return False
    return stack == []
"""
323. Number of Connected Components in an Undirected Graph

You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.

Return the number of connected components in the graph.

Example 1:

Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2
"""
def countComponents(n, edges):
    count = 0
    graph = [[] for _ in range(n)]
    seen = [False for _ in range(n)]
    
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)
        
    def dfs(node):
        for adj in graph[node]:
            if not seen[adj]:
                seen[adj] = True
                dfs(adj)
                
    for i in range(n):
        if not seen[i]:
            count += 1
            seen[i] = True
            dfs(i)            
    return count

"""
156. Binary Tree Upside Down

Given the root of a binary tree, turn the tree upside down and return the new root.

You can turn a binary tree upside down with the following steps:

The original left child becomes the new root.
The original root becomes the new right child.
The original right child becomes the new left child.

The mentioned steps are done level by level, it is guaranteed that every node in the given tree has either 0 or 2 children.

Example 1:

Input: root = [1,2,3,4,5]
Output: [4,5,2,null,null,3,1]
"""
"""
Concise Python recursion solution Time O(N), Space O(logN).
The key idea is that we will need to modify the node links in post-order:
At each node curr, there are two cases to consider,

It's a leaf, no changes to be made, return itself.
Note the description is misleading with it is guaranteed that every node in the given tree has either 0 or 2 children., while there are actually test cases with nodes having only single child. In order to handle both cases, this step checks not curr or not curr.left or not curr.right
If has child (children), we modify the node likes with the following operations:
we need to capture the final root of its left branch by sorting out its left branch first new_root = post_order(curr.left)
modify it's right branch with post_order(curr.right)
Now both branches are sorted, we can modify the local branches involving curr and its immediate child/children (hence post-order) by
attach the right branch root to left child's left branch
attach the curr to left child's right branch
break both links of curr to avoid cycles
All done, return the new_root to the upper level. Note that new_root is not necessarily == curr.left!
"""
def upsideDownBinaryTree(root):
        def post_order(curr: TreeNode) -> TreeNode:
            if not curr or not curr.left or not curr.right:
                return curr
            
            new_root = post_order(curr.left)
            curr.left.left = post_order(curr.right)
            curr.left.right = curr
            curr.left = curr.right = None
            
            return new_root
        
        return post_order(root)
    
"""
636. Exclusive Time of Functions

On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.

Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.

You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". For example, "0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.

A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.

Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.

Example 1:

Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
"""

def exclusiveTime(n, logs):
    stack = collections.deque()
    res = [0 for i in range(n)]
    
    for log in logs:
        log = log.split(':')
        fid, sign, ts = int(log[0]), log[1], int(log[2])
        if sign == 'start':
            if stack:
                res[stack[-1][0]] += ts - stack[-1][1]
            stack.append([fid, ts])

        elif sign == 'end':
            key, value = stack.pop()
            res[key] += ts - value + 1
            if stack:
                stack[-1][1] = ts + 1
            
    return res

"""
611. Valid Triangle Number

Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

Example 1:

Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
"""
def triangleNumber(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    nums.sort()
    ans = 0
    L = len(nums)
    # c < (a+b)
    for i in range(L-1,1,-1):
        c = nums[i]
        start = 0
        end = i-1
        while start < end:
            if nums[start] + nums[end] > c:
                ans += end - start
                end -= 1
            elif nums[start] + nums[end] <= c:
                start += 1
    return ans

"""
13. Roman to Integer

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

 

Example 1:

Input: s = "III"
Output: 3
"""
def romanToInt(s):
    values = {"I": 1,"V": 5,"X": 10,"L": 50,"C": 100,"D": 500,"M": 1000}
    total = 0
    i = 0
    while i < len(s):
        if i+1 < len(s) and values[s[i]] < values[s[i+1]]:
            total += values[s[i+1]] - values[s[i]]
            i += 2
        else:
            total += values[s[i]]
            i += 1
    return total

"""
235. Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: 
“The lowest common ancestor is defined between two nodes p and q as the lowest node in 
T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Example 1:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.

Time Complexity : O(N)O(N), where NN is the number of nodes in the BST. In the worst case we might be visiting all the nodes of the BST.

Space Complexity : O(1)O(1).
"""
def lowestCommonAncestor(root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        # Value of p
        p_val = p.val

        # Value of q
        q_val = q.val

        # Start from the root node of the tree
        node = root

        # Traverse the tree
        while node:

            # Value of current node or parent node.
            parent_val = node.val

            if p_val > parent_val and q_val > parent_val:    
                # If both p and q are greater than parent
                node = node.right
            elif p_val < parent_val and q_val < parent_val:
                # If both p and q are lesser than parent
                node = node.left
            else:
                # We have found the split point, i.e. the LCA node.
                return node
            
"""
236. Lowest Common Ancestor of a Binary Tree

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
"""

def lowestCommonAncestor(root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        # Stack for tree traversal
        stack = [root]
        # Dictionary for parent pointers
        parent = {root: None}

        # Iterate until we find both the nodes p and q
        while p not in parent or q not in parent:

            node = stack.pop()

            # While traversing the tree, keep saving the parent pointers.
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)

        # Ancestors set() for node p.
        ancestors = set()

        # Process all ancestors for node p using parent pointers.
        while p:
            ancestors.add(p)
            p = parent[p]

        # The first ancestor of q which appears in
        # p's ancestor set() is their lowest common ancestor.
        while q not in ancestors:
            q = parent[q]
        return q
    
def lowestCommonAncestor(root, p, q):
    """
    :type root: TreeNode
    :type p: TreeNode
    :type q: TreeNode
    :rtype: TreeNode
    """
    if root is None:
        return None
    
    if (root == p or root == q):
        return root
    
    left = self.lowestCommonAncestor(root.left, p, q)
    right = self.lowestCommonAncestor(root.right, p, q)
    
    if(left is not None and right is not None):
        return root
    
    if(left is None and right is None):
        return None
    
    if(left is not None):
        return left
    
    if(right is not None):
        return right
"""
341. Flatten Nested List Iterator

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

Example 1:

Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
"""
class NestedIterator:
    
    def __init__(self, nestedList: [NestedInteger]):
        def flatten_list(nested_list):
            for nested_integer in nested_list:
                if nested_integer.isInteger():
                    self._integers.append(nested_integer.getInteger())
                else:
                    flatten_list(nested_integer.getList()) 
        self._integers = []
        self._position = -1 # Pointer to previous returned.
        flatten_list(nestedList)
    
    def next(self) -> int:
        self._position += 1
        return self._integers[self._position]
        
    def hasNext(self) -> bool:
        return self._position + 1 < len(self._integers)
    
    
"""
605. Can Place Flowers

You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

 

Example 1:

Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
"""

def canPlaceFlowers(flowerbed, n):
    count = 0
    lent = len(flowerbed)
    for i in range(lent):
        if i ==0:
            if flowerbed[i] ==0 and (lent ==1 or flowerbed[i+1]==0):
                flowerbed[i] = 1
                count += 1
        elif i != (lent-1) and flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:
            
            flowerbed[i] = 1
            count += 1
        else:
            if i == (lent-1) and flowerbed[i-1]==0 and flowerbed[i]==0:
                flowerbed[i] = 1
                count += 1
    return count >= n

"""
516. Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

Example 1:

Input: s = "bbbab"
Output: 4
Explanation: One possible longest palindromic subsequence is "bbbb".
"""
def longestPalindromeSubseq(s):
    # dp[i][j] is the longest palindrmoic subsequence for s[i, j], including j
    n = len(s)
    dp = [[0] * n for _  in range(n)]
    for i in range(n): # the length of a single letter is 1
        dp[i][i] = 1
    for k in range(1, n):
        for i in range(n - k):
            j = i + k
            if s[i] != s[j]:
                dp[i][j] = max(dp[i + 1][j], dp[i][j -1]) if k > 1 else 1
            else: # s[i] == s[j]
                dp[i][j] = dp[i + 1][j - 1] + 2 if k > 1 else 2
    return dp[0][-1]


"""
671. Second Minimum Node In a Binary Tree

Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.

Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.

Example 1:

Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.

Let \text{min1 = root.val}min1 = root.val. When traversing the tree at some node, \text{node}node, if \text{node.val > min1}node.val > min1, we know all values in the subtree at \text{node}node are at least \text{node.val}node.val, so there cannot be a better candidate for the second minimum in this subtree. Thus, we do not need to search this subtree.

Also, as we only care about the second minimum \text{ans}ans, we do not need to record any values that are larger than our current candidate for the second minimum, so unlike Approach #1 we can skip maintaining a Set of values(uniques) entirely.

"""
def findSecondMinimumValue(self, root):
    self.ans = float('inf')
    min1 = root.val

    def dfs(node):
        if node:
            if min1 < node.val < self.ans:
                self.ans = node.val
            elif node.val == min1:
                dfs(node.left)
                dfs(node.right)
    dfs(root)
    return self.ans if self.ans < float('inf') else -1
"""
349. Intersection of Two Arrays

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
"""
def intersection(nums1, nums2):
    """
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: List[int]
    """
    HT = {}
    s = set()
    for i in nums1:
        if i not in HT:
            HT[i] = 1
        
    for i in nums2:
        if i in HT:
            s.add(i)
    return s

"""
350. Intersection of Two Arrays II

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
"""
def intersect(nums1, nums2):           
    set1 = collections.Counter(nums1)
    set2 = collections.Counter(nums2)
    
    res =[]
    for i in set1:
           if i in set2:
                if set1[i] >= set2[i]:
                    for j in range(set2[i]):
                        res.append(i)
                else:
                    for j in range(set1[i]):
                        res.append(i)
    return res
"""
88. Merge Sorted Array

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
"""
def merge(nums1, m, nums2, n):
    
    """
    Do not return anything, modify nums1 in-place instead.
    """
    num1_cpy = nums1[:m]
    nums1[:] = []
    p1 = 0
    p2 = 0
    while p1<m and p2<n:
        if num1_cpy[p1] < nums2[p2]:
            nums1.append(num1_cpy[p1])
            p1 += 1
        else:
            nums1.append(nums2[p2])
            p2 += 1
    
    if p1<m:
        nums1[p1+p2:] = num1_cpy[p1:]
    if p2<n:
        nums1[p1+p2:] =  nums2[p2:]
    
    return nums1
"""
81. Search in Rotated Sorted Array II

There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).

Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].

Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.

You must decrease the overall operation steps as much as possible.

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
"""
def search(nums, target):
    return binSearch(list(set(nums)), 0, len(set(nums))-1, target)
    
def binSearch(nums, l, r, target):
    while l <= r:
        mid = (l+r) // 2
        
        if nums[mid] == target: # found target index
            return True
        
        elif nums[mid] >= nums[l]:
            if target < nums[mid] and target >= nums[l]:
                r = mid - 1
            else:
                l = mid + 1
        
        else:
            if target > nums[mid] and target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return False

"""
127. Word Ladder

Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
"""

def ladderLength(beginWord,endWord,wordList):
    graph = {}
    for char in wordList:
        for s in range(len(char)):
            key = char[:s] +'*'+ char[s+1:]
            if key not in graph:
                graph[key] = [char]
            else:
                graph[key].append(char)    
    queue = deque()
    queue.append([beginWord,0])
    visited = set()
    while queue:
        node,length = queue.popleft()
        if node == endWord:
            return length+1
        for i in range(len(node)):
            common = node[:i] +'*'+ node[i+1:]
            if common in graph:
                for key in graph[common]:
                    if key not in visited:
                        visited.add(key)
                        queue.append([key,length+1])
    
    return -1
"""
528. Random Pick with Weight

You are given an array of positive integers w where w[i] describes the weight of ith index (0-indexed).

We need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking the index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking the index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).

More formally, the p


ability of picking index i is w[i] / sum(w).
"""

class Solution:
    def __init__(self, w):
        """
        :type w: List[int]
        """
        self.prefix_sums = []
        prefix_sum = 0
        for weight in w:
            prefix_sum += weight
            self.prefix_sums.append(prefix_sum)
        self.total_sum = prefix_sum

    def pickIndex(self):
        """
        :rtype: int
        """
        target = self.total_sum * random.random()
        # run a binary search to find the target zone
        low, high = 0, len(self.prefix_sums)
        while low < high:
            mid = low + (high - low) // 2
            if target > self.prefix_sums[mid]:
                low = mid + 1
            else:
                high = mid
        return low
"""
215. Kth Largest Element in an Array

Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
"""

def findKthLargest(nums, k):
	#nums: [3, 2, 1, 5, 6, 4],       k = 2
	
	
	# turn nums list into min heap 
        heapq.heapify(nums)

	#after min heap [1, 2, 3, 5, 6, 4]

	#since we want the kth largest, in this case k = 2, we want the 2nd largest from right to left and that would be [5]
        while len(nums) > k:
            heapq.heappop(nums)
         
		 #after while loop [5, 6]
		# we are left with 2 items because till this point we have been popping from the front of the list
		 # since this is a min heap our first item in the list should be our answer
        
        return nums[0]
    


"""
432. All O`one Data Structure

Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:

AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
 
Example 1:

Input
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output
[null, null, null, "hello", "hello", null, "hello", "leet"]

Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"
"""
class AllOne:
	"""
	Runtime: 68 ms, faster than 97.93% of Python3 online submissions for All O`one Data Structure.
	Memory Usage: 18.8 MB, less than 38.17% of Python3 online submissions for All O`one Data Structure.
	"""

	def __init__(self):
		"""
		Initialize your data structure here.
		"""
		self.myDict={}

	def inc(self, key: str) -> None:
		"""
		Inserts a new key <Key> with value 1. Or increments an existing key by 1.
		"""
		if key in self.myDict:
			self.myDict[key]=self.myDict[key]+1
		else:
			self.myDict[key]=1

	def dec(self, key: str) -> None:
		"""
		Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
		"""
		if self.myDict[key]>1:
			self.myDict[key]=self.myDict[key]-1
		else:
			self.myDict.pop(key)

	def getMaxKey(self) -> str:
		"""
		Returns one of the keys with maximal value.
		"""
		if len(self.myDict.values())==0:
			return ""
		else:
			maxVal=max(self.myDict.values())

			for key in self.myDict.keys():
				if self.myDict[key]==maxVal:
					return key

	def getMinKey(self) -> str:
		"""
		Returns one of the keys with Minimal value.
		"""
		if len(self.myDict.values())==0:
			return ""
		else:
			minVal=min(self.myDict.values())

			for key in self.myDict.keys():
				if self.myDict[key]==minVal:
					return key

"""
706. Design HashMap

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.
 
Example 1:

Input
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
"""

class Bucket:
    def __init__(self):
        self.bucket = []

    def get(self, key):
        for (k, v) in self.bucket:
            if k == key:
                return v
        return -1

    def update(self, key, value):
        found = False
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                self.bucket[i] = (key, value)
                found = True
                break

        if not found:
            self.bucket.append((key, value))

    def remove(self, key):
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                del self.bucket[i]
                
"""
560. Subarray Sum Equals K

Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.

Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
"""
def subarraySum(nums, k):
    repo, count, presum = {}, 0, 0
    repo[0] = 1
    
    for num in nums:
        presum += num
        if presum-k in repo:
            count += repo[presum-k]
        repo[presum] = repo.get(presum, 0) + 1
    return count

"""
973. K Closest Points to Origin

Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).

Example 1:

Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
"""

def kClosest(points, k):
    points.sort(key=lambda p:p[0]**2+p[1]**2)
    return points[:k]

"""
340. Longest Substring with At Most K Distinct Characters

Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.

Example 1:

Input: s = "eceba", k = 2
Output: 3
Explanation: The substring is "ece" with length 3.
"""
def lengthOfLongestSubstringKDistinct(s, k):
        n = len(s)
        if n * k == 0:
            return 0
        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -> its rightmost position
        # in the sliding window
        hashmap = defaultdict()
        max_len = 1
        while right < n:
            # add new character and move right pointer
            hashmap[s[right]] = right
            right += 1
            if len(hashmap) == k + 1:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1
            max_len = max(max_len, right - left)
        return max_len
    
"""
1188. Design Bounded Blocking Queue

Implement a thread-safe bounded blocking queue that has the following methods:

BoundedBlockingQueue(int capacity) The constructor initializes the queue with a maximum capacity.
void enqueue(int element) Adds an element to the front of the queue. If the queue is full, the calling thread is blocked until the queue is no longer full.
int dequeue() Returns the element at the rear of the queue and removes it. If the queue is empty, the calling thread is blocked until the queue is no longer empty.
int size() Returns the number of elements currently in the queue.
Your implementation will be tested using multiple threads at the same time. Each thread will either be a producer thread that only makes calls to the enqueue method or a consumer thread that only makes calls to the dequeue method. The size method will be called after every test case.

Please do not use built-in implementations of bounded blocking queue as this will not be accepted in an interview.

Example 1:

Input:
1
1

["BoundedBlockingQueue","enqueue","dequeue","dequeue","enqueue","enqueue","enqueue","enqueue","dequeue"]
[[2],[1],[],[],[0],[2],[3],[4],[]]

Output:
[1,0,2,2]

Explanation:
Number of producer threads = 1
Number of consumer threads = 1

BoundedBlockingQueue queue = new BoundedBlockingQueue(2);   // initialize the queue with capacity = 2.

queue.enqueue(1);   // The producer thread enqueues 1 to the queue.
queue.dequeue();    // The consumer thread calls dequeue and returns 1 from the queue.
queue.dequeue();    // Since the queue is empty, the consumer thread is blocked.
queue.enqueue(0);   // The producer thread enqueues 0 to the queue. The consumer thread is unblocked and returns 0 from the queue.
queue.enqueue(2);   // The producer thread enqueues 2 to the queue.
queue.enqueue(3);   // The producer thread enqueues 3 to the queue.
queue.enqueue(4);   // The producer thread is blocked because the queue's capacity (2) is reached.
queue.dequeue();    // The consumer thread returns 2 from the queue. The producer thread is unblocked and enqueues 4 to the queue.
queue.size();       // 2 elements remaining in the queue. size() is always called at the end of each test case.
"""
import threading
class BoundedBlockingQueue(object):

    def __init__(self, capacity: int):
        self.cv = threading.Condition()
        self.q = deque()
        self.cap = capacity

    def enqueue(self, element: int) -> None:
        with self.cv:
            while self.cap == len(self.q):
                self.cv.wait()
            self.q.append(element)
            self.cv.notify()

    def dequeue(self) -> int:
        ans = 0
        with self.cv:
            while not self.q:
                self.cv.wait()
            ans = self.q.popleft()
            self.cv.notify()
        return ans
        
    def size(self) -> int:
        return len(self.q)
    
"""
360. Sort Transformed Array

Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.

Example 1:

Input: nums = [-4,-2,2,4], a = 1, b = 3, c = 5
Output: [3,9,15,33]
"""

def sortTransformedArray(nums, a, b, c):
    def func(x, a, b, c):
        res = a*x*x + b*x + c
        return res
    f = []
    for i in range(len(nums)):
        f.append(func(nums[i], a, b, c))
    f = sorted(f)
    return f

"""
721. Accounts Merge - DFS

Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.

Example 1:
Input: 
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
Explanation: 
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
"""
def accountsMerge(accounts):
    em_to_name = {}
    graph = collections.defaultdict(set)
    for acc in accounts:
        name = acc[0]
        for email in acc[1:]:
            graph[acc[1]].add(email)
            graph[email].add(acc[1])
            em_to_name[email] = name
    seen = set()
    ans = []
    for email in graph:
        print(email)
        if email not in seen:
            seen.add(email)
            stack = [email]
            component = []
            while stack:
                node = stack.pop()
                component.append(node)
                for nei in graph[node]:
                    if nei not in seen:
                        seen.add(nei)
                        stack.append(nei)
            ans.append([em_to_name[email]] + sorted(component))
    return ans

"""
1650. Lowest Common Ancestor of a Binary Tree III

Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA).

Each node will have a reference to its parent node. The definition for Node is below:

class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
According to the definition of LCA on Wikipedia: "The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself)."

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
"""
"""
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
"""
from collections import deque


class Solution:
    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
        queue = deque()
        queue.append((p, p))
        visited = set()
        visited.add(p.val)
        
        while queue:
            node, ancestor = queue.popleft()
            if node.val == q.val:
                return ancestor
            else:
                for child in [node.left, node.right]:
                    if (child is not None) and (child.val not in visited):
                        visited.add(child.val)
                        queue.append((child, ancestor))
                if (node.parent is not None) and (node.parent.val not in visited):
                    visited.add(node.parent.val)
                    queue.append((node.parent, node.parent))
                
        return None
    
"""
1249. Minimum Remove to Make Valid Parentheses
Given a string s of '(' , ')' and lowercase English characters. 

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
"""
def minRemoveToMakeValid(s):
    open_par = []
    s = list(s)
    
    for idc, char in enumerate(s):
        if char == '(':
            open_par.append(idc)
        elif char == ')':
            if open_par:
                open_par.pop()
            else:
                s[idc] = ""
    while open_par:
        s[open_par.pop()] = ""
        
    return "".join(s)
"""
1312. Minimum Insertion Steps to Make a String Palindrome

Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

Example 1:

Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we don't need any insertions.
"""
"""
find LCS (Longest Common Subsequence) of given string and reverse of that string.
Then required answer = len(string) - LCS

TC: O(m X n)
SC: O(m X n)

Bottom Up Approach
"""
def minInsertions(s):
    S1, S2 = s, s[::-1]
    m, n = len(s), len(s)
    T = [[-1 for j in range(n + 1)] for i in range(m + 1)]
 
    for i in range(m + 1):
        for j in range(n + 1):
            if(i == 0 or j == 0):
                T[i][j] = 0
            elif(S1[i - 1] == S2[j - 1]):
                T[i][j] = T[i - 1][j - 1] + 1
            else:
                T[i][j] = max(T[i- 1][j], T[i][j - 1])
    
    return (len(s) - T[m][n])

"""
1611. Minimum One Bit Operations to Make Integers Zero

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

 

Example 1:

Input: n = 0
Output: 0
Example 2:

Input: n = 3
Output: 2
Explanation: The binary representation of 3 is "11".
"11" -> "01" with the 2nd operation since the 0th bit is 1.
"01" -> "00" with the 1st operation.
"""

def minimumOneBitOperations(n):
    x = '{0:b}'.format(n)
    y = list(x)
    r = 0
    s = True
    for k in range(len(y)):
        if x[k]=='1' and s:
            r+=(2**(len(y)-k))-1
            s=False
        elif x[k]=='1':
            r-=(2**(len(y)-k))-1
            s=True
    return r

"""
361. Bomb Enemy

Given an m x n matrix grid where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.

The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.
 
Example 1:

Input: grid = [["0","E","0","0"],["E","0","W","E"],["0","E","0","0"]]
Output: 3
"""

class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        ans = 0
        m,n = len(grid), len(grid[0])
        kills = [[0 for i in range(n)] for _ in range(m)]
        self.helper(grid,[0,m],[0,n],+1,kills,False)
        self.helper(grid,[0,m],[n-1,-1],-1,kills,False)
        self.helper(grid,[0,n],[0,m],+1,kills,True)
        self.helper(grid,[0,n],[m-1,-1],-1,kills,True)
        
        for i in range(m):
            for j in range(n):
                ans = max(ans,kills[i][j])
        
        return ans
    
    def helper(self,grid,fixed,var,increment,kills,switch):
        [i,j] = fixed
        [p,q] = var
        for r in range(i,j):
            count = 0
            for c in range(p,q,increment):
                x,y = r,c
                if switch:
                    x,y = c,r
                if grid[x][y] == "E":
                    count += 1
                if grid[x][y] == "W":
                    count = 0
                if grid[x][y] == "0":
                    kills[x][y] += count